/**
 * Generated by @openapi-codegen
 *
 * @version 0.1.0
 */
import * as reactQuery from "@tanstack/react-query";
import { useRagitApIContext, RagitApIContext } from "./ragitApIContext";
import type * as Fetcher from "./ragitApIFetcher";
import { ragitApIFetch } from "./ragitApIFetcher";
import type * as Schemas from "./ragitApISchemas";

export type GetPresignedUrlFilesGetPresignedUrlPostError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type GetPresignedUrlFilesGetPresignedUrlPostVariables = {
  body: Schemas.GetPresignedUrlRequest;
} & RagitApIContext["fetcherOptions"];

export const fetchGetPresignedUrlFilesGetPresignedUrlPost = (
  variables: GetPresignedUrlFilesGetPresignedUrlPostVariables,
  signal?: AbortSignal,
) =>
  ragitApIFetch<
    void,
    GetPresignedUrlFilesGetPresignedUrlPostError,
    Schemas.GetPresignedUrlRequest,
    {},
    {},
    {}
  >({ url: "/files/get_presigned_url", method: "post", ...variables, signal });

export const useGetPresignedUrlFilesGetPresignedUrlPost = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      void,
      GetPresignedUrlFilesGetPresignedUrlPostError,
      GetPresignedUrlFilesGetPresignedUrlPostVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useRagitApIContext();
  return reactQuery.useMutation<
    void,
    GetPresignedUrlFilesGetPresignedUrlPostError,
    GetPresignedUrlFilesGetPresignedUrlPostVariables
  >({
    mutationFn: (variables: GetPresignedUrlFilesGetPresignedUrlPostVariables) =>
      fetchGetPresignedUrlFilesGetPresignedUrlPost({
        ...fetcherOptions,
        ...variables,
      }),
    ...options,
  });
};

export type CompleteUploadFilesCompleteUploadPostError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type CompleteUploadFilesCompleteUploadPostVariables = {
  body: Schemas.MarkUploadStatusRequest;
} & RagitApIContext["fetcherOptions"];

export const fetchCompleteUploadFilesCompleteUploadPost = (
  variables: CompleteUploadFilesCompleteUploadPostVariables,
  signal?: AbortSignal,
) =>
  ragitApIFetch<
    void,
    CompleteUploadFilesCompleteUploadPostError,
    Schemas.MarkUploadStatusRequest,
    {},
    {},
    {}
  >({ url: "/files/complete_upload", method: "post", ...variables, signal });

export const useCompleteUploadFilesCompleteUploadPost = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      void,
      CompleteUploadFilesCompleteUploadPostError,
      CompleteUploadFilesCompleteUploadPostVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useRagitApIContext();
  return reactQuery.useMutation<
    void,
    CompleteUploadFilesCompleteUploadPostError,
    CompleteUploadFilesCompleteUploadPostVariables
  >({
    mutationFn: (variables: CompleteUploadFilesCompleteUploadPostVariables) =>
      fetchCompleteUploadFilesCompleteUploadPost({
        ...fetcherOptions,
        ...variables,
      }),
    ...options,
  });
};

export type GetProjectFilesProjectProjectIdFilesGetPathParams = {
  projectId: string;
};

export type GetProjectFilesProjectProjectIdFilesGetError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type GetProjectFilesProjectProjectIdFilesGetResponse = Schemas.TFile[];

export type GetProjectFilesProjectProjectIdFilesGetVariables = {
  pathParams: GetProjectFilesProjectProjectIdFilesGetPathParams;
} & RagitApIContext["fetcherOptions"];

export const fetchGetProjectFilesProjectProjectIdFilesGet = (
  variables: GetProjectFilesProjectProjectIdFilesGetVariables,
  signal?: AbortSignal,
) =>
  ragitApIFetch<
    GetProjectFilesProjectProjectIdFilesGetResponse,
    GetProjectFilesProjectProjectIdFilesGetError,
    undefined,
    {},
    {},
    GetProjectFilesProjectProjectIdFilesGetPathParams
  >({ url: "/project/{projectId}/files", method: "get", ...variables, signal });

export const useGetProjectFilesProjectProjectIdFilesGet = <
  TData = GetProjectFilesProjectProjectIdFilesGetResponse,
>(
  variables: GetProjectFilesProjectProjectIdFilesGetVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetProjectFilesProjectProjectIdFilesGetResponse,
      GetProjectFilesProjectProjectIdFilesGetError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useRagitApIContext(options);
  return reactQuery.useQuery<
    GetProjectFilesProjectProjectIdFilesGetResponse,
    GetProjectFilesProjectProjectIdFilesGetError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/project/{projectId}/files",
      operationId: "getProjectFilesProjectProjectIdFilesGet",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetProjectFilesProjectProjectIdFilesGet(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type GetContextFilesContextContextIdFilesGetPathParams = {
  contextId: string;
};

export type GetContextFilesContextContextIdFilesGetError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type GetContextFilesContextContextIdFilesGetResponse = Schemas.TFile[];

export type GetContextFilesContextContextIdFilesGetVariables = {
  pathParams: GetContextFilesContextContextIdFilesGetPathParams;
} & RagitApIContext["fetcherOptions"];

export const fetchGetContextFilesContextContextIdFilesGet = (
  variables: GetContextFilesContextContextIdFilesGetVariables,
  signal?: AbortSignal,
) =>
  ragitApIFetch<
    GetContextFilesContextContextIdFilesGetResponse,
    GetContextFilesContextContextIdFilesGetError,
    undefined,
    {},
    {},
    GetContextFilesContextContextIdFilesGetPathParams
  >({ url: "/context/{contextId}/files", method: "get", ...variables, signal });

export const useGetContextFilesContextContextIdFilesGet = <
  TData = GetContextFilesContextContextIdFilesGetResponse,
>(
  variables: GetContextFilesContextContextIdFilesGetVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetContextFilesContextContextIdFilesGetResponse,
      GetContextFilesContextContextIdFilesGetError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useRagitApIContext(options);
  return reactQuery.useQuery<
    GetContextFilesContextContextIdFilesGetResponse,
    GetContextFilesContextContextIdFilesGetError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/context/{contextId}/files",
      operationId: "getContextFilesContextContextIdFilesGet",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetContextFilesContextContextIdFilesGet(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type DeleteFileFilesDeletePostError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type DeleteFileFilesDeletePostVariables = {
  body: Schemas.ApiServiceRoutersFileEndpointsTypesDeleteFileRequest;
} & RagitApIContext["fetcherOptions"];

export const fetchDeleteFileFilesDeletePost = (
  variables: DeleteFileFilesDeletePostVariables,
  signal?: AbortSignal,
) =>
  ragitApIFetch<
    void,
    DeleteFileFilesDeletePostError,
    Schemas.ApiServiceRoutersFileEndpointsTypesDeleteFileRequest,
    {},
    {},
    {}
  >({ url: "/files/delete", method: "post", ...variables, signal });

export const useDeleteFileFilesDeletePost = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      void,
      DeleteFileFilesDeletePostError,
      DeleteFileFilesDeletePostVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useRagitApIContext();
  return reactQuery.useMutation<
    void,
    DeleteFileFilesDeletePostError,
    DeleteFileFilesDeletePostVariables
  >({
    mutationFn: (variables: DeleteFileFilesDeletePostVariables) =>
      fetchDeleteFileFilesDeletePost({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type CreateContextContextCreatePostError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type CreateContextContextCreatePostVariables = {
  body: Schemas.CreateContextRequest;
} & RagitApIContext["fetcherOptions"];

export const fetchCreateContextContextCreatePost = (
  variables: CreateContextContextCreatePostVariables,
  signal?: AbortSignal,
) =>
  ragitApIFetch<
    void,
    CreateContextContextCreatePostError,
    Schemas.CreateContextRequest,
    {},
    {},
    {}
  >({ url: "/context/create", method: "post", ...variables, signal });

export const useCreateContextContextCreatePost = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      void,
      CreateContextContextCreatePostError,
      CreateContextContextCreatePostVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useRagitApIContext();
  return reactQuery.useMutation<
    void,
    CreateContextContextCreatePostError,
    CreateContextContextCreatePostVariables
  >({
    mutationFn: (variables: CreateContextContextCreatePostVariables) =>
      fetchCreateContextContextCreatePost({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type GetContextByReadableIdProjectProjectIdContextReadableIdGetPathParams =
  {
    projectId: string;
    readableId: number;
  };

export type GetContextByReadableIdProjectProjectIdContextReadableIdGetError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type GetContextByReadableIdProjectProjectIdContextReadableIdGetVariables =
  {
    pathParams: GetContextByReadableIdProjectProjectIdContextReadableIdGetPathParams;
  } & RagitApIContext["fetcherOptions"];

export const fetchGetContextByReadableIdProjectProjectIdContextReadableIdGet = (
  variables: GetContextByReadableIdProjectProjectIdContextReadableIdGetVariables,
  signal?: AbortSignal,
) =>
  ragitApIFetch<
    Schemas.TContext,
    GetContextByReadableIdProjectProjectIdContextReadableIdGetError,
    undefined,
    {},
    {},
    GetContextByReadableIdProjectProjectIdContextReadableIdGetPathParams
  >({
    url: "/project/{projectId}/context/{readableId}",
    method: "get",
    ...variables,
    signal,
  });

export const useGetContextByReadableIdProjectProjectIdContextReadableIdGet = <
  TData = Schemas.TContext,
>(
  variables: GetContextByReadableIdProjectProjectIdContextReadableIdGetVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.TContext,
      GetContextByReadableIdProjectProjectIdContextReadableIdGetError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useRagitApIContext(options);
  return reactQuery.useQuery<
    Schemas.TContext,
    GetContextByReadableIdProjectProjectIdContextReadableIdGetError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/project/{projectId}/context/{readableId}",
      operationId: "getContextByReadableIdProjectProjectIdContextReadableIdGet",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetContextByReadableIdProjectProjectIdContextReadableIdGet(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type GetProjectContextsProjectProjectIdContextsGetPathParams = {
  projectId: string;
};

export type GetProjectContextsProjectProjectIdContextsGetError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type GetProjectContextsProjectProjectIdContextsGetResponse =
  Schemas.TContext[];

export type GetProjectContextsProjectProjectIdContextsGetVariables = {
  pathParams: GetProjectContextsProjectProjectIdContextsGetPathParams;
} & RagitApIContext["fetcherOptions"];

export const fetchGetProjectContextsProjectProjectIdContextsGet = (
  variables: GetProjectContextsProjectProjectIdContextsGetVariables,
  signal?: AbortSignal,
) =>
  ragitApIFetch<
    GetProjectContextsProjectProjectIdContextsGetResponse,
    GetProjectContextsProjectProjectIdContextsGetError,
    undefined,
    {},
    {},
    GetProjectContextsProjectProjectIdContextsGetPathParams
  >({
    url: "/project/{projectId}/contexts",
    method: "get",
    ...variables,
    signal,
  });

export const useGetProjectContextsProjectProjectIdContextsGet = <
  TData = GetProjectContextsProjectProjectIdContextsGetResponse,
>(
  variables: GetProjectContextsProjectProjectIdContextsGetVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetProjectContextsProjectProjectIdContextsGetResponse,
      GetProjectContextsProjectProjectIdContextsGetError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useRagitApIContext(options);
  return reactQuery.useQuery<
    GetProjectContextsProjectProjectIdContextsGetResponse,
    GetProjectContextsProjectProjectIdContextsGetError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/project/{projectId}/contexts",
      operationId: "getProjectContextsProjectProjectIdContextsGet",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetProjectContextsProjectProjectIdContextsGet(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type AddFileContextContextIdAddFilePostPathParams = {
  contextId: string;
};

export type AddFileContextContextIdAddFilePostError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type AddFileContextContextIdAddFilePostVariables = {
  body: Schemas.AddFileRequest;
  pathParams: AddFileContextContextIdAddFilePostPathParams;
} & RagitApIContext["fetcherOptions"];

export const fetchAddFileContextContextIdAddFilePost = (
  variables: AddFileContextContextIdAddFilePostVariables,
  signal?: AbortSignal,
) =>
  ragitApIFetch<
    void,
    AddFileContextContextIdAddFilePostError,
    Schemas.AddFileRequest,
    {},
    {},
    AddFileContextContextIdAddFilePostPathParams
  >({
    url: "/context/{contextId}/add_file",
    method: "post",
    ...variables,
    signal,
  });

export const useAddFileContextContextIdAddFilePost = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      void,
      AddFileContextContextIdAddFilePostError,
      AddFileContextContextIdAddFilePostVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useRagitApIContext();
  return reactQuery.useMutation<
    void,
    AddFileContextContextIdAddFilePostError,
    AddFileContextContextIdAddFilePostVariables
  >({
    mutationFn: (variables: AddFileContextContextIdAddFilePostVariables) =>
      fetchAddFileContextContextIdAddFilePost({
        ...fetcherOptions,
        ...variables,
      }),
    ...options,
  });
};

export type RemoveFileContextContextIdRemoveFilePostPathParams = {
  contextId: string;
};

export type RemoveFileContextContextIdRemoveFilePostError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type RemoveFileContextContextIdRemoveFilePostVariables = {
  body: Schemas.ApiServiceRoutersContextEndpointsTypesDeleteFileRequest;
  pathParams: RemoveFileContextContextIdRemoveFilePostPathParams;
} & RagitApIContext["fetcherOptions"];

export const fetchRemoveFileContextContextIdRemoveFilePost = (
  variables: RemoveFileContextContextIdRemoveFilePostVariables,
  signal?: AbortSignal,
) =>
  ragitApIFetch<
    void,
    RemoveFileContextContextIdRemoveFilePostError,
    Schemas.ApiServiceRoutersContextEndpointsTypesDeleteFileRequest,
    {},
    {},
    RemoveFileContextContextIdRemoveFilePostPathParams
  >({
    url: "/context/{contextId}/remove_file",
    method: "post",
    ...variables,
    signal,
  });

export const useRemoveFileContextContextIdRemoveFilePost = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      void,
      RemoveFileContextContextIdRemoveFilePostError,
      RemoveFileContextContextIdRemoveFilePostVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useRagitApIContext();
  return reactQuery.useMutation<
    void,
    RemoveFileContextContextIdRemoveFilePostError,
    RemoveFileContextContextIdRemoveFilePostVariables
  >({
    mutationFn: (
      variables: RemoveFileContextContextIdRemoveFilePostVariables,
    ) =>
      fetchRemoveFileContextContextIdRemoveFilePost({
        ...fetcherOptions,
        ...variables,
      }),
    ...options,
  });
};

export type GetDocumentsContextContextIdDocumentsGetPathParams = {
  contextId: string;
};

export type GetDocumentsContextContextIdDocumentsGetQueryParams = {
  offset?: string;
  /**
   * @default 10
   */
  limit?: number;
};

export type GetDocumentsContextContextIdDocumentsGetError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type GetDocumentsContextContextIdDocumentsGetResponse =
  Schemas.TDocument[];

export type GetDocumentsContextContextIdDocumentsGetVariables = {
  pathParams: GetDocumentsContextContextIdDocumentsGetPathParams;
  queryParams?: GetDocumentsContextContextIdDocumentsGetQueryParams;
} & RagitApIContext["fetcherOptions"];

export const fetchGetDocumentsContextContextIdDocumentsGet = (
  variables: GetDocumentsContextContextIdDocumentsGetVariables,
  signal?: AbortSignal,
) =>
  ragitApIFetch<
    GetDocumentsContextContextIdDocumentsGetResponse,
    GetDocumentsContextContextIdDocumentsGetError,
    undefined,
    {},
    GetDocumentsContextContextIdDocumentsGetQueryParams,
    GetDocumentsContextContextIdDocumentsGetPathParams
  >({
    url: "/context/{contextId}/documents",
    method: "get",
    ...variables,
    signal,
  });

export const useGetDocumentsContextContextIdDocumentsGet = <
  TData = GetDocumentsContextContextIdDocumentsGetResponse,
>(
  variables: GetDocumentsContextContextIdDocumentsGetVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetDocumentsContextContextIdDocumentsGetResponse,
      GetDocumentsContextContextIdDocumentsGetError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useRagitApIContext(options);
  return reactQuery.useQuery<
    GetDocumentsContextContextIdDocumentsGetResponse,
    GetDocumentsContextContextIdDocumentsGetError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/context/{contextId}/documents",
      operationId: "getDocumentsContextContextIdDocumentsGet",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetDocumentsContextContextIdDocumentsGet(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type DeleteContextContextContextIdDeletePathParams = {
  contextId: string;
};

export type DeleteContextContextContextIdDeleteError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type DeleteContextContextContextIdDeleteVariables = {
  pathParams: DeleteContextContextContextIdDeletePathParams;
} & RagitApIContext["fetcherOptions"];

export const fetchDeleteContextContextContextIdDelete = (
  variables: DeleteContextContextContextIdDeleteVariables,
  signal?: AbortSignal,
) =>
  ragitApIFetch<
    void,
    DeleteContextContextContextIdDeleteError,
    undefined,
    {},
    {},
    DeleteContextContextContextIdDeletePathParams
  >({ url: "/context/{contextId}", method: "delete", ...variables, signal });

export const useDeleteContextContextContextIdDelete = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      void,
      DeleteContextContextContextIdDeleteError,
      DeleteContextContextContextIdDeleteVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useRagitApIContext();
  return reactQuery.useMutation<
    void,
    DeleteContextContextContextIdDeleteError,
    DeleteContextContextContextIdDeleteVariables
  >({
    mutationFn: (variables: DeleteContextContextContextIdDeleteVariables) =>
      fetchDeleteContextContextContextIdDelete({
        ...fetcherOptions,
        ...variables,
      }),
    ...options,
  });
};

export type CreateProjectProjectCreatePostError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type CreateProjectProjectCreatePostVariables = {
  body: Schemas.CreateProjectRequest;
} & RagitApIContext["fetcherOptions"];

export const fetchCreateProjectProjectCreatePost = (
  variables: CreateProjectProjectCreatePostVariables,
  signal?: AbortSignal,
) =>
  ragitApIFetch<
    void,
    CreateProjectProjectCreatePostError,
    Schemas.CreateProjectRequest,
    {},
    {},
    {}
  >({ url: "/project/create", method: "post", ...variables, signal });

export const useCreateProjectProjectCreatePost = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      void,
      CreateProjectProjectCreatePostError,
      CreateProjectProjectCreatePostVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useRagitApIContext();
  return reactQuery.useMutation<
    void,
    CreateProjectProjectCreatePostError,
    CreateProjectProjectCreatePostVariables
  >({
    mutationFn: (variables: CreateProjectProjectCreatePostVariables) =>
      fetchCreateProjectProjectCreatePost({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type GetProjectsProjectGetGetQueryParams = {
  /**
   * @default 10
   */
  limit?: number;
  /**
   * @default 0
   */
  offset?: number;
};

export type GetProjectsProjectGetGetError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetProjectsProjectGetGetResponse = Schemas.TProject[];

export type GetProjectsProjectGetGetVariables = {
  queryParams?: GetProjectsProjectGetGetQueryParams;
} & RagitApIContext["fetcherOptions"];

export const fetchGetProjectsProjectGetGet = (
  variables: GetProjectsProjectGetGetVariables,
  signal?: AbortSignal,
) =>
  ragitApIFetch<
    GetProjectsProjectGetGetResponse,
    GetProjectsProjectGetGetError,
    undefined,
    {},
    GetProjectsProjectGetGetQueryParams,
    {}
  >({ url: "/project/get", method: "get", ...variables, signal });

export const useGetProjectsProjectGetGet = <
  TData = GetProjectsProjectGetGetResponse,
>(
  variables: GetProjectsProjectGetGetVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetProjectsProjectGetGetResponse,
      GetProjectsProjectGetGetError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useRagitApIContext(options);
  return reactQuery.useQuery<
    GetProjectsProjectGetGetResponse,
    GetProjectsProjectGetGetError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/project/get",
      operationId: "getProjectsProjectGetGet",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetProjectsProjectGetGet(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type GetProjectProjectGetProjectIdGetPathParams = {
  projectId: string;
};

export type GetProjectProjectGetProjectIdGetError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetProjectProjectGetProjectIdGetVariables = {
  pathParams: GetProjectProjectGetProjectIdGetPathParams;
} & RagitApIContext["fetcherOptions"];

export const fetchGetProjectProjectGetProjectIdGet = (
  variables: GetProjectProjectGetProjectIdGetVariables,
  signal?: AbortSignal,
) =>
  ragitApIFetch<
    Schemas.TProject,
    GetProjectProjectGetProjectIdGetError,
    undefined,
    {},
    {},
    GetProjectProjectGetProjectIdGetPathParams
  >({ url: "/project/get/{projectId}", method: "get", ...variables, signal });

export const useGetProjectProjectGetProjectIdGet = <TData = Schemas.TProject>(
  variables: GetProjectProjectGetProjectIdGetVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.TProject,
      GetProjectProjectGetProjectIdGetError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useRagitApIContext(options);
  return reactQuery.useQuery<
    Schemas.TProject,
    GetProjectProjectGetProjectIdGetError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/project/get/{projectId}",
      operationId: "getProjectProjectGetProjectIdGet",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetProjectProjectGetProjectIdGet(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type GetProjectByUuidProjectGetbyuuidProjectIdGetPathParams = {
  projectId: string;
};

export type GetProjectByUuidProjectGetbyuuidProjectIdGetError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type GetProjectByUuidProjectGetbyuuidProjectIdGetVariables = {
  pathParams: GetProjectByUuidProjectGetbyuuidProjectIdGetPathParams;
} & RagitApIContext["fetcherOptions"];

export const fetchGetProjectByUuidProjectGetbyuuidProjectIdGet = (
  variables: GetProjectByUuidProjectGetbyuuidProjectIdGetVariables,
  signal?: AbortSignal,
) =>
  ragitApIFetch<
    Schemas.TProject,
    GetProjectByUuidProjectGetbyuuidProjectIdGetError,
    undefined,
    {},
    {},
    GetProjectByUuidProjectGetbyuuidProjectIdGetPathParams
  >({
    url: "/project/getbyuuid/{projectId}",
    method: "get",
    ...variables,
    signal,
  });

export const useGetProjectByUuidProjectGetbyuuidProjectIdGet = <
  TData = Schemas.TProject,
>(
  variables: GetProjectByUuidProjectGetbyuuidProjectIdGetVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.TProject,
      GetProjectByUuidProjectGetbyuuidProjectIdGetError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useRagitApIContext(options);
  return reactQuery.useQuery<
    Schemas.TProject,
    GetProjectByUuidProjectGetbyuuidProjectIdGetError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/project/getbyuuid/{projectId}",
      operationId: "getProjectByUuidProjectGetbyuuidProjectIdGet",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetProjectByUuidProjectGetbyuuidProjectIdGet(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type SignupAuthSignupPostError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type SignupAuthSignupPostVariables = {
  body: Schemas.SignupRequest;
} & RagitApIContext["fetcherOptions"];

export const fetchSignupAuthSignupPost = (
  variables: SignupAuthSignupPostVariables,
  signal?: AbortSignal,
) =>
  ragitApIFetch<
    Schemas.TAuthResponse,
    SignupAuthSignupPostError,
    Schemas.SignupRequest,
    {},
    {},
    {}
  >({ url: "/auth/signup", method: "post", ...variables, signal });

export const useSignupAuthSignupPost = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.TAuthResponse,
      SignupAuthSignupPostError,
      SignupAuthSignupPostVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useRagitApIContext();
  return reactQuery.useMutation<
    Schemas.TAuthResponse,
    SignupAuthSignupPostError,
    SignupAuthSignupPostVariables
  >({
    mutationFn: (variables: SignupAuthSignupPostVariables) =>
      fetchSignupAuthSignupPost({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type LoginAuthLoginPostError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type LoginAuthLoginPostVariables = {
  body: Schemas.LoginRequest;
} & RagitApIContext["fetcherOptions"];

export const fetchLoginAuthLoginPost = (
  variables: LoginAuthLoginPostVariables,
  signal?: AbortSignal,
) =>
  ragitApIFetch<
    Schemas.TAuthResponse,
    LoginAuthLoginPostError,
    Schemas.LoginRequest,
    {},
    {},
    {}
  >({ url: "/auth/login", method: "post", ...variables, signal });

export const useLoginAuthLoginPost = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.TAuthResponse,
      LoginAuthLoginPostError,
      LoginAuthLoginPostVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useRagitApIContext();
  return reactQuery.useMutation<
    Schemas.TAuthResponse,
    LoginAuthLoginPostError,
    LoginAuthLoginPostVariables
  >({
    mutationFn: (variables: LoginAuthLoginPostVariables) =>
      fetchLoginAuthLoginPost({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type GetUserAuthGetGetError = Fetcher.ErrorWrapper<undefined>;

export type GetUserAuthGetGetVariables = RagitApIContext["fetcherOptions"];

export const fetchGetUserAuthGetGet = (
  variables: GetUserAuthGetGetVariables,
  signal?: AbortSignal,
) =>
  ragitApIFetch<Schemas.TUser, GetUserAuthGetGetError, undefined, {}, {}, {}>({
    url: "/auth/get",
    method: "get",
    ...variables,
    signal,
  });

export const useGetUserAuthGetGet = <TData = Schemas.TUser>(
  variables: GetUserAuthGetGetVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.TUser, GetUserAuthGetGetError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useRagitApIContext(options);
  return reactQuery.useQuery<Schemas.TUser, GetUserAuthGetGetError, TData>({
    queryKey: queryKeyFn({
      path: "/auth/get",
      operationId: "getUserAuthGetGet",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetUserAuthGetGet({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type ChatPlaygroundPlaygroundIdChatPostPathParams = {
  playgroundId: string;
};

export type ChatPlaygroundPlaygroundIdChatPostError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type ChatPlaygroundPlaygroundIdChatPostVariables = {
  body: Schemas.ChatRequest;
  pathParams: ChatPlaygroundPlaygroundIdChatPostPathParams;
} & RagitApIContext["fetcherOptions"];

export const fetchChatPlaygroundPlaygroundIdChatPost = (
  variables: ChatPlaygroundPlaygroundIdChatPostVariables,
  signal?: AbortSignal,
) =>
  ragitApIFetch<
    void,
    ChatPlaygroundPlaygroundIdChatPostError,
    Schemas.ChatRequest,
    {},
    {},
    ChatPlaygroundPlaygroundIdChatPostPathParams
  >({
    url: "/playground/{playgroundId}/chat",
    method: "post",
    ...variables,
    signal,
  });

export const useChatPlaygroundPlaygroundIdChatPost = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      void,
      ChatPlaygroundPlaygroundIdChatPostError,
      ChatPlaygroundPlaygroundIdChatPostVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useRagitApIContext();
  return reactQuery.useMutation<
    void,
    ChatPlaygroundPlaygroundIdChatPostError,
    ChatPlaygroundPlaygroundIdChatPostVariables
  >({
    mutationFn: (variables: ChatPlaygroundPlaygroundIdChatPostVariables) =>
      fetchChatPlaygroundPlaygroundIdChatPost({
        ...fetcherOptions,
        ...variables,
      }),
    ...options,
  });
};

export type GetChatHistoryPlaygroundPlaygroundIdChatGetPathParams = {
  playgroundId: string;
};

export type GetChatHistoryPlaygroundPlaygroundIdChatGetError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type GetChatHistoryPlaygroundPlaygroundIdChatGetResponse =
  Schemas.ChatResponse[];

export type GetChatHistoryPlaygroundPlaygroundIdChatGetVariables = {
  pathParams: GetChatHistoryPlaygroundPlaygroundIdChatGetPathParams;
} & RagitApIContext["fetcherOptions"];

export const fetchGetChatHistoryPlaygroundPlaygroundIdChatGet = (
  variables: GetChatHistoryPlaygroundPlaygroundIdChatGetVariables,
  signal?: AbortSignal,
) =>
  ragitApIFetch<
    GetChatHistoryPlaygroundPlaygroundIdChatGetResponse,
    GetChatHistoryPlaygroundPlaygroundIdChatGetError,
    undefined,
    {},
    {},
    GetChatHistoryPlaygroundPlaygroundIdChatGetPathParams
  >({
    url: "/playground/{playgroundId}/chat",
    method: "get",
    ...variables,
    signal,
  });

export const useGetChatHistoryPlaygroundPlaygroundIdChatGet = <
  TData = GetChatHistoryPlaygroundPlaygroundIdChatGetResponse,
>(
  variables: GetChatHistoryPlaygroundPlaygroundIdChatGetVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetChatHistoryPlaygroundPlaygroundIdChatGetResponse,
      GetChatHistoryPlaygroundPlaygroundIdChatGetError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useRagitApIContext(options);
  return reactQuery.useQuery<
    GetChatHistoryPlaygroundPlaygroundIdChatGetResponse,
    GetChatHistoryPlaygroundPlaygroundIdChatGetError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/playground/{playgroundId}/chat",
      operationId: "getChatHistoryPlaygroundPlaygroundIdChatGet",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetChatHistoryPlaygroundPlaygroundIdChatGet(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type GetPlaygroundPlaygroundPlaygroundIdGetPathParams = {
  playgroundId: string;
};

export type GetPlaygroundPlaygroundPlaygroundIdGetError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetPlaygroundPlaygroundPlaygroundIdGetVariables = {
  pathParams: GetPlaygroundPlaygroundPlaygroundIdGetPathParams;
} & RagitApIContext["fetcherOptions"];

export const fetchGetPlaygroundPlaygroundPlaygroundIdGet = (
  variables: GetPlaygroundPlaygroundPlaygroundIdGetVariables,
  signal?: AbortSignal,
) =>
  ragitApIFetch<
    Schemas.PlayGroundResponse,
    GetPlaygroundPlaygroundPlaygroundIdGetError,
    undefined,
    {},
    {},
    GetPlaygroundPlaygroundPlaygroundIdGetPathParams
  >({ url: "/playground/{playgroundId}", method: "get", ...variables, signal });

export const useGetPlaygroundPlaygroundPlaygroundIdGet = <
  TData = Schemas.PlayGroundResponse,
>(
  variables: GetPlaygroundPlaygroundPlaygroundIdGetVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.PlayGroundResponse,
      GetPlaygroundPlaygroundPlaygroundIdGetError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useRagitApIContext(options);
  return reactQuery.useQuery<
    Schemas.PlayGroundResponse,
    GetPlaygroundPlaygroundPlaygroundIdGetError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/playground/{playgroundId}",
      operationId: "getPlaygroundPlaygroundPlaygroundIdGet",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetPlaygroundPlaygroundPlaygroundIdGet(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type QueryOperation =
  | {
      path: "/project/{projectId}/files";
      operationId: "getProjectFilesProjectProjectIdFilesGet";
      variables: GetProjectFilesProjectProjectIdFilesGetVariables;
    }
  | {
      path: "/context/{contextId}/files";
      operationId: "getContextFilesContextContextIdFilesGet";
      variables: GetContextFilesContextContextIdFilesGetVariables;
    }
  | {
      path: "/project/{projectId}/context/{readableId}";
      operationId: "getContextByReadableIdProjectProjectIdContextReadableIdGet";
      variables: GetContextByReadableIdProjectProjectIdContextReadableIdGetVariables;
    }
  | {
      path: "/project/{projectId}/contexts";
      operationId: "getProjectContextsProjectProjectIdContextsGet";
      variables: GetProjectContextsProjectProjectIdContextsGetVariables;
    }
  | {
      path: "/context/{contextId}/documents";
      operationId: "getDocumentsContextContextIdDocumentsGet";
      variables: GetDocumentsContextContextIdDocumentsGetVariables;
    }
  | {
      path: "/project/get";
      operationId: "getProjectsProjectGetGet";
      variables: GetProjectsProjectGetGetVariables;
    }
  | {
      path: "/project/get/{projectId}";
      operationId: "getProjectProjectGetProjectIdGet";
      variables: GetProjectProjectGetProjectIdGetVariables;
    }
  | {
      path: "/project/getbyuuid/{projectId}";
      operationId: "getProjectByUuidProjectGetbyuuidProjectIdGet";
      variables: GetProjectByUuidProjectGetbyuuidProjectIdGetVariables;
    }
  | {
      path: "/auth/get";
      operationId: "getUserAuthGetGet";
      variables: GetUserAuthGetGetVariables;
    }
  | {
      path: "/playground/{playgroundId}/chat";
      operationId: "getChatHistoryPlaygroundPlaygroundIdChatGet";
      variables: GetChatHistoryPlaygroundPlaygroundIdChatGetVariables;
    }
  | {
      path: "/playground/{playgroundId}";
      operationId: "getPlaygroundPlaygroundPlaygroundIdGet";
      variables: GetPlaygroundPlaygroundPlaygroundIdGetVariables;
    };
